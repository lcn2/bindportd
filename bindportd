#!/usr/bin/perl -wT
#
# bindport - bind to tcp or udp ports
#
# usage:
#	bindport [-b] [-c] [-s] [-v] [-w] proto/port ...
#
#	-b	run in background after binding to ports
#	-c	pre-close all open files (except STDOUT/STDERR if also -v)
#	-v	verbose
#	-s	block all signals
#	-w	wait forever
#
#	proto	tcp or udp
#	port	port number or port number-range or port name
#
# @(#) $Revision: 1.4 $
# @(#) $Id: bindport,v 1.4 2000/02/04 11:50:22 chongo Exp chongo $
# @(#) $Source: /usr/local/src/etc/bindport/RCS/bindport,v $
#
# Copyright (c) 2000 by Landon Curt Noll.  All Rights Reserved.
#
# Permission to use, copy, modify, and distribute this software and
# its documentation for any purpose and without fee is hereby granted,
# provided that the above copyright, this permission notice and text
# this comment, and the disclaimer below appear in all of the following:
#
#       supporting documentation
#       source copies
#       source works derived from this source
#       binaries derived from this source or from derived source
#
# LANDON CURT NOLL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO
# EVENT SHALL LANDON CURT NOLL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
# USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.
#
# chongo <was here> /\oo/\
#
# Share and enjoy!

# NOTE: Executing the following command:
#
#	bindport -b -c -s -w udp/1024-1043 udp/socks udp/2049 udp/5632 \
#			     udp/31337 udp/31789 udp/31790 \
#			     tcp/1024-1043 tcp/socks tcp/1114 tcp/1243 \
#			     tcp/2000 tcp/2049 tcp/12345-12346 tcp/20034
#
# right after the network is started (see /etc/rc.d/init.d/network) is useful
# as it grabs and holds on to ports that are often the subject of system
# crackers and other network attacks.
#
# Even if you are behind router, packet filter or ipchain control where the
# inbound and/or outbound packets to certain ports are blocked, system and
# user applications may still try to bind to these ports.  If your application
# is unlucky enough to pick one if these blocked ports, it will appear that
# the network is dead or non-responsive.
# 
# Applications may try to bind to blocks ports perfect valid reasons. 
# It is perfectly reasonable for a program to use almost any random unused 
# privileged port.  In fact there are facilities where an application
# will ask for any random, unprivileged and unused port on which to listen
# or make connections.  Such applications have no way of knowing that the
# router/packet filter/ipchain will block them.
#
# WARNING: The above port list may not be complete.  It may also contain
#	   services that you want to use (such as socks).  Just the command
#	   to suit your needs and current network attacks.

# NOTE: To test if some ports are in use, try:
#
#	if bindport -c tcp/3000 udp/3000; then
#	    echo ports not being used
#	else
#	    echo some of the ports are in use
#	fi
#
# The program will exit 0 if it was able to bind and close all of the
# ports successfully.  Otherwise it will exit non-zero.  By using -c,
# one ensures that no error messages will be printed.  Of course, doing:
#
#	if bindport udp/23209 2>/dev/null; then echo it is free; fi
#
# will also work without forcing the pre-close of files.


# requirements
#
use strict;
use Socket;
use IO::Socket;
use Getopt::Std;
use POSIX;
use vars qw($opt_b $opt_c $opt_s $opt_v $opt_w);

# my vars
#
my @sock;	# socket objects
#
my $tcp;	# tcp protocol number
my $udp;	# udp protocol number
#
my $usage = "usage:\n" .
	    "$0 [-b] [-c] [-s] [-v] [-w] " .
	    "{tcp|udp}/{portnum|port-range|portname} ...\n" .
	    "\n" .
	    "\t-b\trun in background after binding to all ports\n" .
	    "\t-c\tpre-close all files (except STDOUT/STDERR if also -v)\n" .
	    "\t-s\tblock all signals\n" .
	    "\t-v\tverbose\n" .
	    "\t-w\twait forever\n";

MAIN:
{
    my $proto_arg;	# protocol name ("tcp" or "udp")
    my $port_arg;	# port name/number part of the arg
    my $i;

    # setup
    #
    (undef, undef, $tcp) = getprotobyname("tcp");
    die "$0: cannot determine tcp protocol number\n" unless defined $tcp;
    (undef, undef, $udp) = getprotobyname("udp");
    die "$0: cannot determine udp protocol number\n" unless defined $udp;

    # parse args
    #
    if (!getopts('bcsvw') || !defined($ARGV[0])) {
	die $usage;
    }
    if (defined $opt_v) {
	select STDOUT;
	$| = 1;
    }

    # pre-close all files if requested
    #
    if (defined $opt_c) {

	# pre-close the standard big 3 descriptors
	#
	# We do not close STDOUT and STDERR if we also were given -v
	#
	POSIX::close(0);
	POSIX::close(1) unless defined $opt_v;
	POSIX::close(2) unless defined $opt_v;

	# close from 3 upward
	#
	print "closing STDIN and file 3 thru file ", OPEN_MAX, "\n" if $opt_v;
	for ($i=3; $i < OPEN_MAX; ++$i) {
	    POSIX::close($i);
	}
    }

    # turn off signals
    #
    if (defined $opt_s) {
	print "ignoring almost all signals..." if defined $opt_v;
	&sig_off();
	print "\n" if defined $opt_v;
    }

    # form sockets for each arg
    #
    for ($i=0; $i < scalar(@ARGV); ++$i) {

	# check arg syntax
	#
	if ($ARGV[$i] !~ m#^(tcp|udp)/(.*)$#) {
	    print STDERR "$0: $ARGV[$i]: does not start with tcp/ or udp/\n";
	    die $usage;
	}
	$proto_arg = $1;
	$port_arg = $2;
	if (! defined($port_arg) || $port_arg eq "") {
	    print STDERR "$0: $ARGV[$i]: must end with ";
	    print STDERR "/portname or /portnum or /port-range\n";
	    die $usage;
	}

	# hold ports over a range
	#
	if ($port_arg =~ m#^(\d+)\-(\d+)$#) {

	    my $low_port;	# low port number of a range
	    my $high_port;	# high port number of a range
	    my $port;

	    # inspect the range
	    #
	    if ($1 < $2) {
		$low_port = $1;
		$high_port = $2;
	    } else {
		$low_port = $2;
		$high_port = $1;
	    }

	    # hold each port in the range
	    #
	    for ($port = $low_port; $port <= $high_port; ++$port) {
		push(@sock, &hold_port($proto_arg, $port));
	    }

	# or hold a single port
	#
	} else {
	    push(@sock, &hold_port($proto_arg, $port_arg));
    	}
    }

    # fork in background if -b
    #
    if (defined $opt_b) {
	my $pid;	# parent => child pid, child => 0

	$pid = fork;
	die "$0: cannot fork: $!\n" unless defined($pid);
	exit(0) if $pid;
    }

    # sleep forever if requested
    #
    if (defined $opt_w) {
	print "waiting forever ..." if defined $opt_v;
	select undef, undef, undef, undef;
	die "select forever ended!\n";
    }

    # all done
    #
    for ($i=0; $i < scalar(@sock); ++$i) {
	$sock[$i]->close();
    }
    exit(0);
}


# sig_off - turn off all signals (that we can)
#
sub sig_off()
{
    for my $sig (keys %SIG) {
	$SIG{$sig} = 'IGNORE';
    }
}


# hold_port - hold a port by binding to it
#
# usage:
#	$s = &hold_port($proto_arg, $port);
#
#	$proto_arg	protocol name ("tcp" or "udp")
#	$port_arg	port number or name
#
# returns:
#	IO::Socket::INET object
#
# NOTE: The $proto_arg is used for error message output only.
#
sub hold_port()
{
    my ($proto_arg, $port_arg) = @_;		# get args 
    my $type;		# socket type (SOCK_STREAM | SOCK_DGRAM)
    my $proto;		# protocol number (tcp(6) or udp(17))
    my $port_name;	# port name (number or name(number))
    my $port;		# port number
    my $s;		# socket object

    # setup parameters based on TCP or UDP
    #
    if ($proto_arg eq "tcp") {
	$proto = $tcp;
	$type = SOCK_STREAM;
    } elsif ($proto_arg eq "udp") {
	$proto = $udp;
	$type = SOCK_DGRAM;
    } else {
	die "$0: protocol name is not tcp or ucp\n";
    }

    # determine port name(number)
    #
    if ($port_arg =~ /^\d+$/) {
	$port = $port_arg;
	$port_name = scalar(getservbyport($port_arg,$proto_arg));
    } else {
	$port_name = $port_arg;
	$port = scalar(getservbyname($port_arg,$proto_arg));
	if (!defined $port) {
	    print STDERR "$0: unknown proto/port: $proto_arg/$port_arg\n";
	    die $usage;
	}
    }
    if (defined $port_name) {
	$port_name = "$port_name($port)";
    } else {
	$port_name = "$port";
    }

    # bind to the port
    #
    $s = &bind_port($type, $proto, $proto_arg, $port, $port_name);
    print "holding $proto_arg/$port_name\n" if defined $opt_v;
    return $s;
}


# bind_port - bind a port by binding to it
#
# usage:
#	$s = &bind_port($type, $proto, $proto_arg, $port, $port_name);
#
#	$type		socket type (SOCK_STREAM | SOCK_DGRAM)
#	$proto		protocol number
#	$proto_arg	protocol name ("tcp" or "udp")
#	$port		port number
#	$port_name	port name (either number or name(number))
#
# returns:
#	IO::Socket::INET object
#
# NOTE: The $proto_arg and $port_name are used for error message output only.
#
sub bind_port($$$)
{
    my ($type, $proto, $proto_arg, $port, $port_name) = @_;	# get args 
    my $s;	# socket object

    # construct a socket object
    #
    $s = IO::Socket::INET->new();
    if (! defined($s)) {
	die "$0: failed to form the socket object\n";
    }
    if (! $s->socket(PF_INET, $type, $proto)) {
	die "$0: cannot create $proto_arg socket: $!\n";
    }

    # bind the socket
    #
    if (! $s->bind($port, INADDR_ANY)) {
	die "$0: cannot bind to $port_name: $!\n";
    }

    # save the socket
    #
    return $s;
}
