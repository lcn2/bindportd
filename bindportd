#!/usr/bin/perl -wT
#
# bindport - bind to tcp or udp ports
#
# usage:
#	bindport [-b] [-v] [-w] proto/port ...
#
#	-b	block all signals
#	-v	verbose
#	-w	wait forever
#
#	proto	tcp or udp
#	port	port number or name
#
# @(#) $Revision: 1.1 $
# @(#) $Id: holdport.pl,v 1.1 2000/02/04 09:49:57 chongo Exp chongo $
# @(#) $Source: /usr/local/src/etc/holdport/RCS/holdport.pl,v $
#
# Copyright (c) 2000 by Landon Curt Noll.  All Rights Reserved.
#
# Permission to use, copy, modify, and distribute this software and
# its documentation for any purpose and without fee is hereby granted,
# provided that the above copyright, this permission notice and text
# this comment, and the disclaimer below appear in all of the following:
#
#       supporting documentation
#       source copies
#       source works derived from this source
#       binaries derived from this source or from derived source
#
# LANDON CURT NOLL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO
# EVENT SHALL LANDON CURT NOLL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
# USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.
#
# chongo <was here> /\oo/\
#
# Share and enjoy!

# requirements
#
use strict;
use Socket;
use IO::Socket;
use Getopt::Std;
use vars qw($opt_b $opt_v $opt_w);

# my vars
#
my @sock;	# socket objects
#
my $tcp;	# tcp protocol number
my $udp;	# udp protocol number
#
my $usage = "usage: $0 [-b] [-v] [-w] {tcp|udp}/{portnum|portname} ...\n";

MAIN:
{
    my $proto_arg;	# protocol name ("tcp" or "udp")
    my $proto;		# protocol number (tcp(6) or udp(17))
    my $port_arg;	# port name/number part of the arg
    my $type;		# socket type (SOCK_STREAM | SOCK_DGRAM)
    my $i;

    # setup
    #
    select STDOUT;
    $| = 1;
    (undef, undef, $tcp) = getprotobyname("tcp");
    die "$0: cannot determine tcp protocol number\n" unless defined $tcp;
    (undef, undef, $udp) = getprotobyname("udp");
    die "$0: cannot determine udp protocol number\n" unless defined $udp;

    # parse args
    #
    if (!getopts('bvw') || !defined($ARGV[0])) {
	die $usage;
    }

    # form sockets for each arg
    #
    for ($i=0; $i < scalar(@ARGV); ++$i) {

	# check arg syntax
	#
	if ($ARGV[$i] !~ m#^(tcp|udp)/(.*)$#) {
	    print STDERR "$0: $ARGV[$i]: does not start with tcp/ or udp/\n";
	    die $usage;
	}
	$proto_arg = $1;
	$port_arg = $2;
	if (! defined($port_arg) || $port_arg eq "") {
	    print STDERR "$0: $ARGV[$i]: must end with :portname or :portnum\n";
	    die $usage;
	}

	# setup parameters based on TCP or UDP
	#
	if ($proto_arg eq "tcp") {
	    $proto = $tcp;
	    $type = SOCK_STREAM;
	} else {
	    $proto = $udp;
	    $type = SOCK_DGRAM;
	}

	# hold the port
	#
	push(@sock, &hold_port($type, $proto, $proto_arg, $port_arg));
    }

    # turn off signals
    #
    if (defined $opt_b) {
	print "ignoring almost all signals..." if defined $opt_v;
	&sig_off();
	print "\n" if defined $opt_v;
    }

    # sleep forever if requested
    #
    if (defined $opt_w) {
	print "waiting forever ..." if defined $opt_v;
	select undef, undef, undef, undef;
	die "select forever ended!\n";
    }

    # all done
    #
    for ($i=0; $i < scalar(@sock); ++$i) {
	$sock[$i]->close();
    }
    exit(0);
}


# sig_off - turn off all signals (that we can)
#
sub sig_off()
{
    for my $sig (keys %SIG) {
	$SIG{$sig} = 'IGNORE';
    }
}


# hold_port - hold a port by binding to it
#
# usage:
#	&hold_port($type, $proto, $proto_arg, $port);
#
#	$type		socket type (SOCK_STREAM | SOCK_DGRAM)
#	$proto		protocol number (tcp(6) or udp(17))
#	$proto_arg	protocol name ("tcp" or "udp")
#	$port_arg	port number or name
#
# returns:
#	IO::Socket::INET object
#
# NOTE: The $proto_arg is used for error message output only.
#
sub hold_port()
{
    my ($type, $proto, $proto_arg, $port_arg) = @_;		# get args 
    my $port_name;	# port name (number or name(number))
    my $port;		# port number
    my $s;		# socket object

    # determine port name(number)
    #
    if ($port_arg =~ /^\d+$/) {
	$port = $port_arg;
	$port_name = scalar(getservbyport($port_arg,$proto_arg));
    } else {
	$port_name = $port_arg;
	$port = scalar(getservbyname($port_arg,$proto_arg));
	if (!defined $port) {
	    print STDERR "$0: unknown proto/port: $proto_arg/$port_arg\n";
	    die $usage;
	}
    }
    if (defined $port_name) {
	$port_name = "$port_name($port)";
    } else {
	$port_name = "$port";
    }

    # bind to the port
    #
    $s = &bind_port($type, $proto, $proto_arg, $port, $port_name);
    print "holding $proto_arg/$port_name\n" if defined $opt_v;
    return $s;
}


# bind_port - bind a port by binding to it
#
# usage:
#	$s = &bind_port($type, $proto, $proto_arg, $port, $port_name);
#
#	$type		socket type (SOCK_STREAM | SOCK_DGRAM)
#	$proto		protocol number
#	$proto_arg	protocol name ("tcp" or "udp")
#	$port		port number
#	$port_name	port name (either number or name(number))
#
# returns:
#	IO::Socket::INET object
#
# NOTE: The $proto_arg and $port_name are used for error message output only.
#
sub bind_port($$$)
{
    my ($type, $proto, $proto_arg, $port, $port_name) = @_;	# get args 
    my $s;	# socket object

    # construct a socket object
    #
    $s = IO::Socket::INET->new();
    if (! defined($s)) {
	die "$0: failed to form the socket object\n";
    }
    if (! $s->socket(PF_INET, $type, $proto)) {
	die "$0: cannot create $proto_arg socket: $!\n";
    }

    # bind the socket
    #
    if (! $s->bind($port, INADDR_ANY)) {
	die "$0: cannot bind to $port_name: $!\n";
    }

    # save the socket
    #
    return $s;
}
